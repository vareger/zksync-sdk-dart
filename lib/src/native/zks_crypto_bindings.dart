// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Dart bindings to call zks crypto functions
class ZksCryptoBindings {
  /// Holds the Dynamic library.
  final ffi.DynamicLibrary _dylib;

  /// The symbols are looked up in [dynamicLibrary].
  ZksCryptoBindings(ffi.DynamicLibrary dynamicLibrary)
      : _dylib = dynamicLibrary;

  /// Initializes thread local storage of the parameters used for calculations.
  /// Calling this before other calls is optional since parameters will be initialized when needed.
  /// Can save time for the first call of other functions in the thread
  /// since it takes time to init parameters.
  void zks_crypto_init() {
    _zks_crypto_init ??=
        _dylib.lookupFunction<_c_zks_crypto_init, _dart_zks_crypto_init>(
            'zks_crypto_init');
    return _zks_crypto_init();
  }

  _dart_zks_crypto_init _zks_crypto_init;

  int zks_crypto_private_key_from_seed(
    ffi.Pointer<ffi.Uint8> seed,
    int seed_len,
    ffi.Pointer<ZksPrivateKey> private_key,
  ) {
    _zks_crypto_private_key_from_seed ??= _dylib.lookupFunction<
            _c_zks_crypto_private_key_from_seed,
            _dart_zks_crypto_private_key_from_seed>(
        'zks_crypto_private_key_from_seed');
    return _zks_crypto_private_key_from_seed(
      seed,
      seed_len,
      private_key,
    );
  }

  _dart_zks_crypto_private_key_from_seed _zks_crypto_private_key_from_seed;

  int zks_crypto_private_key_to_public_key(
    ffi.Pointer<ZksPrivateKey> private_key,
    ffi.Pointer<ZksPackedPublicKey> public_key,
  ) {
    _zks_crypto_private_key_to_public_key ??= _dylib.lookupFunction<
            _c_zks_crypto_private_key_to_public_key,
            _dart_zks_crypto_private_key_to_public_key>(
        'zks_crypto_private_key_to_public_key');
    return _zks_crypto_private_key_to_public_key(
      private_key,
      public_key,
    );
  }

  _dart_zks_crypto_private_key_to_public_key
      _zks_crypto_private_key_to_public_key;

  int zks_crypto_public_key_to_pubkey_hash(
    ffi.Pointer<ZksPackedPublicKey> public_key,
    ffi.Pointer<ZksPubkeyHash> pubkey_hash,
  ) {
    _zks_crypto_public_key_to_pubkey_hash ??= _dylib.lookupFunction<
            _c_zks_crypto_public_key_to_pubkey_hash,
            _dart_zks_crypto_public_key_to_pubkey_hash>(
        'zks_crypto_public_key_to_pubkey_hash');
    return _zks_crypto_public_key_to_pubkey_hash(
      public_key,
      pubkey_hash,
    );
  }

  _dart_zks_crypto_public_key_to_pubkey_hash
      _zks_crypto_public_key_to_pubkey_hash;

  /// We use musig Schnorr signature scheme.
  /// It is impossible to restore signer for signature, that is why we provide public key of the signer
  /// along with signature.
  /// [0..32] - packed r point of the signature.
  /// [32..64] - s point of the signature.
  int zks_crypto_sign_musig(
    ffi.Pointer<ZksPrivateKey> private_key,
    ffi.Pointer<ffi.Uint8> msg,
    int msg_len,
    ffi.Pointer<ZksSignature> signature_output,
  ) {
    _zks_crypto_sign_musig ??= _dylib.lookupFunction<_c_zks_crypto_sign_musig,
        _dart_zks_crypto_sign_musig>('zks_crypto_sign_musig');
    return _zks_crypto_sign_musig(
      private_key,
      msg,
      msg_len,
      signature_output,
    );
  }

  _dart_zks_crypto_sign_musig _zks_crypto_sign_musig;
}

abstract class MUSIG_SIGN_RES {
  static const int MUSIG_SIGN_OK = 0;
  static const int MUSIG_SIGN_MSG_TOO_LONG = 1;
}

abstract class PRIVATE_KEY_FROM_SEED_RES {
  static const int PRIVATE_KEY_FROM_SEED_OK = 0;

  /// Seed should be at least 32 bytes long
  static const int PRIVATE_KEY_FROM_SEED_SEED_TOO_SHORT = 1;
}

abstract class PUBKEY_HASH_FROM_PUBKEY_RES {
  static const int PUBKEY_HASH_FROM_PUBKEY_OK = 0;
}

abstract class PUBLIC_KEY_FROM_PRIVATE_RES {
  static const int PUBLIC_KEY_FROM_PRIVATE_OK = 0;
}

class ZksPrivateKey extends ffi.Struct {
  @ffi.Uint8()
  int _unique_data_item_0;
  @ffi.Uint8()
  int _unique_data_item_1;
  @ffi.Uint8()
  int _unique_data_item_2;
  @ffi.Uint8()
  int _unique_data_item_3;
  @ffi.Uint8()
  int _unique_data_item_4;
  @ffi.Uint8()
  int _unique_data_item_5;
  @ffi.Uint8()
  int _unique_data_item_6;
  @ffi.Uint8()
  int _unique_data_item_7;
  @ffi.Uint8()
  int _unique_data_item_8;
  @ffi.Uint8()
  int _unique_data_item_9;
  @ffi.Uint8()
  int _unique_data_item_10;
  @ffi.Uint8()
  int _unique_data_item_11;
  @ffi.Uint8()
  int _unique_data_item_12;
  @ffi.Uint8()
  int _unique_data_item_13;
  @ffi.Uint8()
  int _unique_data_item_14;
  @ffi.Uint8()
  int _unique_data_item_15;
  @ffi.Uint8()
  int _unique_data_item_16;
  @ffi.Uint8()
  int _unique_data_item_17;
  @ffi.Uint8()
  int _unique_data_item_18;
  @ffi.Uint8()
  int _unique_data_item_19;
  @ffi.Uint8()
  int _unique_data_item_20;
  @ffi.Uint8()
  int _unique_data_item_21;
  @ffi.Uint8()
  int _unique_data_item_22;
  @ffi.Uint8()
  int _unique_data_item_23;
  @ffi.Uint8()
  int _unique_data_item_24;
  @ffi.Uint8()
  int _unique_data_item_25;
  @ffi.Uint8()
  int _unique_data_item_26;
  @ffi.Uint8()
  int _unique_data_item_27;
  @ffi.Uint8()
  int _unique_data_item_28;
  @ffi.Uint8()
  int _unique_data_item_29;
  @ffi.Uint8()
  int _unique_data_item_30;
  @ffi.Uint8()
  int _unique_data_item_31;

  /// Helper for array `data`.
  ArrayHelper_ZksPrivateKey_data_level0 get data =>
      ArrayHelper_ZksPrivateKey_data_level0(this, [32], 0, 0);
}

/// Helper for array `data` in struct `ZksPrivateKey`.
class ArrayHelper_ZksPrivateKey_data_level0 {
  final ZksPrivateKey _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_ZksPrivateKey_data_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_data_item_0;
      case 1:
        return _struct._unique_data_item_1;
      case 2:
        return _struct._unique_data_item_2;
      case 3:
        return _struct._unique_data_item_3;
      case 4:
        return _struct._unique_data_item_4;
      case 5:
        return _struct._unique_data_item_5;
      case 6:
        return _struct._unique_data_item_6;
      case 7:
        return _struct._unique_data_item_7;
      case 8:
        return _struct._unique_data_item_8;
      case 9:
        return _struct._unique_data_item_9;
      case 10:
        return _struct._unique_data_item_10;
      case 11:
        return _struct._unique_data_item_11;
      case 12:
        return _struct._unique_data_item_12;
      case 13:
        return _struct._unique_data_item_13;
      case 14:
        return _struct._unique_data_item_14;
      case 15:
        return _struct._unique_data_item_15;
      case 16:
        return _struct._unique_data_item_16;
      case 17:
        return _struct._unique_data_item_17;
      case 18:
        return _struct._unique_data_item_18;
      case 19:
        return _struct._unique_data_item_19;
      case 20:
        return _struct._unique_data_item_20;
      case 21:
        return _struct._unique_data_item_21;
      case 22:
        return _struct._unique_data_item_22;
      case 23:
        return _struct._unique_data_item_23;
      case 24:
        return _struct._unique_data_item_24;
      case 25:
        return _struct._unique_data_item_25;
      case 26:
        return _struct._unique_data_item_26;
      case 27:
        return _struct._unique_data_item_27;
      case 28:
        return _struct._unique_data_item_28;
      case 29:
        return _struct._unique_data_item_29;
      case 30:
        return _struct._unique_data_item_30;
      case 31:
        return _struct._unique_data_item_31;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_data_item_0 = value;
        break;
      case 1:
        _struct._unique_data_item_1 = value;
        break;
      case 2:
        _struct._unique_data_item_2 = value;
        break;
      case 3:
        _struct._unique_data_item_3 = value;
        break;
      case 4:
        _struct._unique_data_item_4 = value;
        break;
      case 5:
        _struct._unique_data_item_5 = value;
        break;
      case 6:
        _struct._unique_data_item_6 = value;
        break;
      case 7:
        _struct._unique_data_item_7 = value;
        break;
      case 8:
        _struct._unique_data_item_8 = value;
        break;
      case 9:
        _struct._unique_data_item_9 = value;
        break;
      case 10:
        _struct._unique_data_item_10 = value;
        break;
      case 11:
        _struct._unique_data_item_11 = value;
        break;
      case 12:
        _struct._unique_data_item_12 = value;
        break;
      case 13:
        _struct._unique_data_item_13 = value;
        break;
      case 14:
        _struct._unique_data_item_14 = value;
        break;
      case 15:
        _struct._unique_data_item_15 = value;
        break;
      case 16:
        _struct._unique_data_item_16 = value;
        break;
      case 17:
        _struct._unique_data_item_17 = value;
        break;
      case 18:
        _struct._unique_data_item_18 = value;
        break;
      case 19:
        _struct._unique_data_item_19 = value;
        break;
      case 20:
        _struct._unique_data_item_20 = value;
        break;
      case 21:
        _struct._unique_data_item_21 = value;
        break;
      case 22:
        _struct._unique_data_item_22 = value;
        break;
      case 23:
        _struct._unique_data_item_23 = value;
        break;
      case 24:
        _struct._unique_data_item_24 = value;
        break;
      case 25:
        _struct._unique_data_item_25 = value;
        break;
      case 26:
        _struct._unique_data_item_26 = value;
        break;
      case 27:
        _struct._unique_data_item_27 = value;
        break;
      case 28:
        _struct._unique_data_item_28 = value;
        break;
      case 29:
        _struct._unique_data_item_29 = value;
        break;
      case 30:
        _struct._unique_data_item_30 = value;
        break;
      case 31:
        _struct._unique_data_item_31 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

class ZksPackedPublicKey extends ffi.Struct {
  @ffi.Uint8()
  int _unique_data_item_0;
  @ffi.Uint8()
  int _unique_data_item_1;
  @ffi.Uint8()
  int _unique_data_item_2;
  @ffi.Uint8()
  int _unique_data_item_3;
  @ffi.Uint8()
  int _unique_data_item_4;
  @ffi.Uint8()
  int _unique_data_item_5;
  @ffi.Uint8()
  int _unique_data_item_6;
  @ffi.Uint8()
  int _unique_data_item_7;
  @ffi.Uint8()
  int _unique_data_item_8;
  @ffi.Uint8()
  int _unique_data_item_9;
  @ffi.Uint8()
  int _unique_data_item_10;
  @ffi.Uint8()
  int _unique_data_item_11;
  @ffi.Uint8()
  int _unique_data_item_12;
  @ffi.Uint8()
  int _unique_data_item_13;
  @ffi.Uint8()
  int _unique_data_item_14;
  @ffi.Uint8()
  int _unique_data_item_15;
  @ffi.Uint8()
  int _unique_data_item_16;
  @ffi.Uint8()
  int _unique_data_item_17;
  @ffi.Uint8()
  int _unique_data_item_18;
  @ffi.Uint8()
  int _unique_data_item_19;
  @ffi.Uint8()
  int _unique_data_item_20;
  @ffi.Uint8()
  int _unique_data_item_21;
  @ffi.Uint8()
  int _unique_data_item_22;
  @ffi.Uint8()
  int _unique_data_item_23;
  @ffi.Uint8()
  int _unique_data_item_24;
  @ffi.Uint8()
  int _unique_data_item_25;
  @ffi.Uint8()
  int _unique_data_item_26;
  @ffi.Uint8()
  int _unique_data_item_27;
  @ffi.Uint8()
  int _unique_data_item_28;
  @ffi.Uint8()
  int _unique_data_item_29;
  @ffi.Uint8()
  int _unique_data_item_30;
  @ffi.Uint8()
  int _unique_data_item_31;

  /// Helper for array `data`.
  ArrayHelper_ZksPackedPublicKey_data_level0 get data =>
      ArrayHelper_ZksPackedPublicKey_data_level0(this, [32], 0, 0);
}

/// Helper for array `data` in struct `ZksPackedPublicKey`.
class ArrayHelper_ZksPackedPublicKey_data_level0 {
  final ZksPackedPublicKey _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_ZksPackedPublicKey_data_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_data_item_0;
      case 1:
        return _struct._unique_data_item_1;
      case 2:
        return _struct._unique_data_item_2;
      case 3:
        return _struct._unique_data_item_3;
      case 4:
        return _struct._unique_data_item_4;
      case 5:
        return _struct._unique_data_item_5;
      case 6:
        return _struct._unique_data_item_6;
      case 7:
        return _struct._unique_data_item_7;
      case 8:
        return _struct._unique_data_item_8;
      case 9:
        return _struct._unique_data_item_9;
      case 10:
        return _struct._unique_data_item_10;
      case 11:
        return _struct._unique_data_item_11;
      case 12:
        return _struct._unique_data_item_12;
      case 13:
        return _struct._unique_data_item_13;
      case 14:
        return _struct._unique_data_item_14;
      case 15:
        return _struct._unique_data_item_15;
      case 16:
        return _struct._unique_data_item_16;
      case 17:
        return _struct._unique_data_item_17;
      case 18:
        return _struct._unique_data_item_18;
      case 19:
        return _struct._unique_data_item_19;
      case 20:
        return _struct._unique_data_item_20;
      case 21:
        return _struct._unique_data_item_21;
      case 22:
        return _struct._unique_data_item_22;
      case 23:
        return _struct._unique_data_item_23;
      case 24:
        return _struct._unique_data_item_24;
      case 25:
        return _struct._unique_data_item_25;
      case 26:
        return _struct._unique_data_item_26;
      case 27:
        return _struct._unique_data_item_27;
      case 28:
        return _struct._unique_data_item_28;
      case 29:
        return _struct._unique_data_item_29;
      case 30:
        return _struct._unique_data_item_30;
      case 31:
        return _struct._unique_data_item_31;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_data_item_0 = value;
        break;
      case 1:
        _struct._unique_data_item_1 = value;
        break;
      case 2:
        _struct._unique_data_item_2 = value;
        break;
      case 3:
        _struct._unique_data_item_3 = value;
        break;
      case 4:
        _struct._unique_data_item_4 = value;
        break;
      case 5:
        _struct._unique_data_item_5 = value;
        break;
      case 6:
        _struct._unique_data_item_6 = value;
        break;
      case 7:
        _struct._unique_data_item_7 = value;
        break;
      case 8:
        _struct._unique_data_item_8 = value;
        break;
      case 9:
        _struct._unique_data_item_9 = value;
        break;
      case 10:
        _struct._unique_data_item_10 = value;
        break;
      case 11:
        _struct._unique_data_item_11 = value;
        break;
      case 12:
        _struct._unique_data_item_12 = value;
        break;
      case 13:
        _struct._unique_data_item_13 = value;
        break;
      case 14:
        _struct._unique_data_item_14 = value;
        break;
      case 15:
        _struct._unique_data_item_15 = value;
        break;
      case 16:
        _struct._unique_data_item_16 = value;
        break;
      case 17:
        _struct._unique_data_item_17 = value;
        break;
      case 18:
        _struct._unique_data_item_18 = value;
        break;
      case 19:
        _struct._unique_data_item_19 = value;
        break;
      case 20:
        _struct._unique_data_item_20 = value;
        break;
      case 21:
        _struct._unique_data_item_21 = value;
        break;
      case 22:
        _struct._unique_data_item_22 = value;
        break;
      case 23:
        _struct._unique_data_item_23 = value;
        break;
      case 24:
        _struct._unique_data_item_24 = value;
        break;
      case 25:
        _struct._unique_data_item_25 = value;
        break;
      case 26:
        _struct._unique_data_item_26 = value;
        break;
      case 27:
        _struct._unique_data_item_27 = value;
        break;
      case 28:
        _struct._unique_data_item_28 = value;
        break;
      case 29:
        _struct._unique_data_item_29 = value;
        break;
      case 30:
        _struct._unique_data_item_30 = value;
        break;
      case 31:
        _struct._unique_data_item_31 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

class ZksPubkeyHash extends ffi.Struct {
  @ffi.Uint8()
  int _unique_data_item_0;
  @ffi.Uint8()
  int _unique_data_item_1;
  @ffi.Uint8()
  int _unique_data_item_2;
  @ffi.Uint8()
  int _unique_data_item_3;
  @ffi.Uint8()
  int _unique_data_item_4;
  @ffi.Uint8()
  int _unique_data_item_5;
  @ffi.Uint8()
  int _unique_data_item_6;
  @ffi.Uint8()
  int _unique_data_item_7;
  @ffi.Uint8()
  int _unique_data_item_8;
  @ffi.Uint8()
  int _unique_data_item_9;
  @ffi.Uint8()
  int _unique_data_item_10;
  @ffi.Uint8()
  int _unique_data_item_11;
  @ffi.Uint8()
  int _unique_data_item_12;
  @ffi.Uint8()
  int _unique_data_item_13;
  @ffi.Uint8()
  int _unique_data_item_14;
  @ffi.Uint8()
  int _unique_data_item_15;
  @ffi.Uint8()
  int _unique_data_item_16;
  @ffi.Uint8()
  int _unique_data_item_17;
  @ffi.Uint8()
  int _unique_data_item_18;
  @ffi.Uint8()
  int _unique_data_item_19;

  /// Helper for array `data`.
  ArrayHelper_ZksPubkeyHash_data_level0 get data =>
      ArrayHelper_ZksPubkeyHash_data_level0(this, [20], 0, 0);
}

/// Helper for array `data` in struct `ZksPubkeyHash`.
class ArrayHelper_ZksPubkeyHash_data_level0 {
  final ZksPubkeyHash _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_ZksPubkeyHash_data_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_data_item_0;
      case 1:
        return _struct._unique_data_item_1;
      case 2:
        return _struct._unique_data_item_2;
      case 3:
        return _struct._unique_data_item_3;
      case 4:
        return _struct._unique_data_item_4;
      case 5:
        return _struct._unique_data_item_5;
      case 6:
        return _struct._unique_data_item_6;
      case 7:
        return _struct._unique_data_item_7;
      case 8:
        return _struct._unique_data_item_8;
      case 9:
        return _struct._unique_data_item_9;
      case 10:
        return _struct._unique_data_item_10;
      case 11:
        return _struct._unique_data_item_11;
      case 12:
        return _struct._unique_data_item_12;
      case 13:
        return _struct._unique_data_item_13;
      case 14:
        return _struct._unique_data_item_14;
      case 15:
        return _struct._unique_data_item_15;
      case 16:
        return _struct._unique_data_item_16;
      case 17:
        return _struct._unique_data_item_17;
      case 18:
        return _struct._unique_data_item_18;
      case 19:
        return _struct._unique_data_item_19;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_data_item_0 = value;
        break;
      case 1:
        _struct._unique_data_item_1 = value;
        break;
      case 2:
        _struct._unique_data_item_2 = value;
        break;
      case 3:
        _struct._unique_data_item_3 = value;
        break;
      case 4:
        _struct._unique_data_item_4 = value;
        break;
      case 5:
        _struct._unique_data_item_5 = value;
        break;
      case 6:
        _struct._unique_data_item_6 = value;
        break;
      case 7:
        _struct._unique_data_item_7 = value;
        break;
      case 8:
        _struct._unique_data_item_8 = value;
        break;
      case 9:
        _struct._unique_data_item_9 = value;
        break;
      case 10:
        _struct._unique_data_item_10 = value;
        break;
      case 11:
        _struct._unique_data_item_11 = value;
        break;
      case 12:
        _struct._unique_data_item_12 = value;
        break;
      case 13:
        _struct._unique_data_item_13 = value;
        break;
      case 14:
        _struct._unique_data_item_14 = value;
        break;
      case 15:
        _struct._unique_data_item_15 = value;
        break;
      case 16:
        _struct._unique_data_item_16 = value;
        break;
      case 17:
        _struct._unique_data_item_17 = value;
        break;
      case 18:
        _struct._unique_data_item_18 = value;
        break;
      case 19:
        _struct._unique_data_item_19 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

class ZksSignature extends ffi.Struct {
  @ffi.Uint8()
  int _unique_data_item_0;
  @ffi.Uint8()
  int _unique_data_item_1;
  @ffi.Uint8()
  int _unique_data_item_2;
  @ffi.Uint8()
  int _unique_data_item_3;
  @ffi.Uint8()
  int _unique_data_item_4;
  @ffi.Uint8()
  int _unique_data_item_5;
  @ffi.Uint8()
  int _unique_data_item_6;
  @ffi.Uint8()
  int _unique_data_item_7;
  @ffi.Uint8()
  int _unique_data_item_8;
  @ffi.Uint8()
  int _unique_data_item_9;
  @ffi.Uint8()
  int _unique_data_item_10;
  @ffi.Uint8()
  int _unique_data_item_11;
  @ffi.Uint8()
  int _unique_data_item_12;
  @ffi.Uint8()
  int _unique_data_item_13;
  @ffi.Uint8()
  int _unique_data_item_14;
  @ffi.Uint8()
  int _unique_data_item_15;
  @ffi.Uint8()
  int _unique_data_item_16;
  @ffi.Uint8()
  int _unique_data_item_17;
  @ffi.Uint8()
  int _unique_data_item_18;
  @ffi.Uint8()
  int _unique_data_item_19;
  @ffi.Uint8()
  int _unique_data_item_20;
  @ffi.Uint8()
  int _unique_data_item_21;
  @ffi.Uint8()
  int _unique_data_item_22;
  @ffi.Uint8()
  int _unique_data_item_23;
  @ffi.Uint8()
  int _unique_data_item_24;
  @ffi.Uint8()
  int _unique_data_item_25;
  @ffi.Uint8()
  int _unique_data_item_26;
  @ffi.Uint8()
  int _unique_data_item_27;
  @ffi.Uint8()
  int _unique_data_item_28;
  @ffi.Uint8()
  int _unique_data_item_29;
  @ffi.Uint8()
  int _unique_data_item_30;
  @ffi.Uint8()
  int _unique_data_item_31;
  @ffi.Uint8()
  int _unique_data_item_32;
  @ffi.Uint8()
  int _unique_data_item_33;
  @ffi.Uint8()
  int _unique_data_item_34;
  @ffi.Uint8()
  int _unique_data_item_35;
  @ffi.Uint8()
  int _unique_data_item_36;
  @ffi.Uint8()
  int _unique_data_item_37;
  @ffi.Uint8()
  int _unique_data_item_38;
  @ffi.Uint8()
  int _unique_data_item_39;
  @ffi.Uint8()
  int _unique_data_item_40;
  @ffi.Uint8()
  int _unique_data_item_41;
  @ffi.Uint8()
  int _unique_data_item_42;
  @ffi.Uint8()
  int _unique_data_item_43;
  @ffi.Uint8()
  int _unique_data_item_44;
  @ffi.Uint8()
  int _unique_data_item_45;
  @ffi.Uint8()
  int _unique_data_item_46;
  @ffi.Uint8()
  int _unique_data_item_47;
  @ffi.Uint8()
  int _unique_data_item_48;
  @ffi.Uint8()
  int _unique_data_item_49;
  @ffi.Uint8()
  int _unique_data_item_50;
  @ffi.Uint8()
  int _unique_data_item_51;
  @ffi.Uint8()
  int _unique_data_item_52;
  @ffi.Uint8()
  int _unique_data_item_53;
  @ffi.Uint8()
  int _unique_data_item_54;
  @ffi.Uint8()
  int _unique_data_item_55;
  @ffi.Uint8()
  int _unique_data_item_56;
  @ffi.Uint8()
  int _unique_data_item_57;
  @ffi.Uint8()
  int _unique_data_item_58;
  @ffi.Uint8()
  int _unique_data_item_59;
  @ffi.Uint8()
  int _unique_data_item_60;
  @ffi.Uint8()
  int _unique_data_item_61;
  @ffi.Uint8()
  int _unique_data_item_62;
  @ffi.Uint8()
  int _unique_data_item_63;

  /// Helper for array `data`.
  ArrayHelper_ZksSignature_data_level0 get data =>
      ArrayHelper_ZksSignature_data_level0(this, [64], 0, 0);
}

/// Helper for array `data` in struct `ZksSignature`.
class ArrayHelper_ZksSignature_data_level0 {
  final ZksSignature _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_ZksSignature_data_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_data_item_0;
      case 1:
        return _struct._unique_data_item_1;
      case 2:
        return _struct._unique_data_item_2;
      case 3:
        return _struct._unique_data_item_3;
      case 4:
        return _struct._unique_data_item_4;
      case 5:
        return _struct._unique_data_item_5;
      case 6:
        return _struct._unique_data_item_6;
      case 7:
        return _struct._unique_data_item_7;
      case 8:
        return _struct._unique_data_item_8;
      case 9:
        return _struct._unique_data_item_9;
      case 10:
        return _struct._unique_data_item_10;
      case 11:
        return _struct._unique_data_item_11;
      case 12:
        return _struct._unique_data_item_12;
      case 13:
        return _struct._unique_data_item_13;
      case 14:
        return _struct._unique_data_item_14;
      case 15:
        return _struct._unique_data_item_15;
      case 16:
        return _struct._unique_data_item_16;
      case 17:
        return _struct._unique_data_item_17;
      case 18:
        return _struct._unique_data_item_18;
      case 19:
        return _struct._unique_data_item_19;
      case 20:
        return _struct._unique_data_item_20;
      case 21:
        return _struct._unique_data_item_21;
      case 22:
        return _struct._unique_data_item_22;
      case 23:
        return _struct._unique_data_item_23;
      case 24:
        return _struct._unique_data_item_24;
      case 25:
        return _struct._unique_data_item_25;
      case 26:
        return _struct._unique_data_item_26;
      case 27:
        return _struct._unique_data_item_27;
      case 28:
        return _struct._unique_data_item_28;
      case 29:
        return _struct._unique_data_item_29;
      case 30:
        return _struct._unique_data_item_30;
      case 31:
        return _struct._unique_data_item_31;
      case 32:
        return _struct._unique_data_item_32;
      case 33:
        return _struct._unique_data_item_33;
      case 34:
        return _struct._unique_data_item_34;
      case 35:
        return _struct._unique_data_item_35;
      case 36:
        return _struct._unique_data_item_36;
      case 37:
        return _struct._unique_data_item_37;
      case 38:
        return _struct._unique_data_item_38;
      case 39:
        return _struct._unique_data_item_39;
      case 40:
        return _struct._unique_data_item_40;
      case 41:
        return _struct._unique_data_item_41;
      case 42:
        return _struct._unique_data_item_42;
      case 43:
        return _struct._unique_data_item_43;
      case 44:
        return _struct._unique_data_item_44;
      case 45:
        return _struct._unique_data_item_45;
      case 46:
        return _struct._unique_data_item_46;
      case 47:
        return _struct._unique_data_item_47;
      case 48:
        return _struct._unique_data_item_48;
      case 49:
        return _struct._unique_data_item_49;
      case 50:
        return _struct._unique_data_item_50;
      case 51:
        return _struct._unique_data_item_51;
      case 52:
        return _struct._unique_data_item_52;
      case 53:
        return _struct._unique_data_item_53;
      case 54:
        return _struct._unique_data_item_54;
      case 55:
        return _struct._unique_data_item_55;
      case 56:
        return _struct._unique_data_item_56;
      case 57:
        return _struct._unique_data_item_57;
      case 58:
        return _struct._unique_data_item_58;
      case 59:
        return _struct._unique_data_item_59;
      case 60:
        return _struct._unique_data_item_60;
      case 61:
        return _struct._unique_data_item_61;
      case 62:
        return _struct._unique_data_item_62;
      case 63:
        return _struct._unique_data_item_63;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_data_item_0 = value;
        break;
      case 1:
        _struct._unique_data_item_1 = value;
        break;
      case 2:
        _struct._unique_data_item_2 = value;
        break;
      case 3:
        _struct._unique_data_item_3 = value;
        break;
      case 4:
        _struct._unique_data_item_4 = value;
        break;
      case 5:
        _struct._unique_data_item_5 = value;
        break;
      case 6:
        _struct._unique_data_item_6 = value;
        break;
      case 7:
        _struct._unique_data_item_7 = value;
        break;
      case 8:
        _struct._unique_data_item_8 = value;
        break;
      case 9:
        _struct._unique_data_item_9 = value;
        break;
      case 10:
        _struct._unique_data_item_10 = value;
        break;
      case 11:
        _struct._unique_data_item_11 = value;
        break;
      case 12:
        _struct._unique_data_item_12 = value;
        break;
      case 13:
        _struct._unique_data_item_13 = value;
        break;
      case 14:
        _struct._unique_data_item_14 = value;
        break;
      case 15:
        _struct._unique_data_item_15 = value;
        break;
      case 16:
        _struct._unique_data_item_16 = value;
        break;
      case 17:
        _struct._unique_data_item_17 = value;
        break;
      case 18:
        _struct._unique_data_item_18 = value;
        break;
      case 19:
        _struct._unique_data_item_19 = value;
        break;
      case 20:
        _struct._unique_data_item_20 = value;
        break;
      case 21:
        _struct._unique_data_item_21 = value;
        break;
      case 22:
        _struct._unique_data_item_22 = value;
        break;
      case 23:
        _struct._unique_data_item_23 = value;
        break;
      case 24:
        _struct._unique_data_item_24 = value;
        break;
      case 25:
        _struct._unique_data_item_25 = value;
        break;
      case 26:
        _struct._unique_data_item_26 = value;
        break;
      case 27:
        _struct._unique_data_item_27 = value;
        break;
      case 28:
        _struct._unique_data_item_28 = value;
        break;
      case 29:
        _struct._unique_data_item_29 = value;
        break;
      case 30:
        _struct._unique_data_item_30 = value;
        break;
      case 31:
        _struct._unique_data_item_31 = value;
        break;
      case 32:
        _struct._unique_data_item_32 = value;
        break;
      case 33:
        _struct._unique_data_item_33 = value;
        break;
      case 34:
        _struct._unique_data_item_34 = value;
        break;
      case 35:
        _struct._unique_data_item_35 = value;
        break;
      case 36:
        _struct._unique_data_item_36 = value;
        break;
      case 37:
        _struct._unique_data_item_37 = value;
        break;
      case 38:
        _struct._unique_data_item_38 = value;
        break;
      case 39:
        _struct._unique_data_item_39 = value;
        break;
      case 40:
        _struct._unique_data_item_40 = value;
        break;
      case 41:
        _struct._unique_data_item_41 = value;
        break;
      case 42:
        _struct._unique_data_item_42 = value;
        break;
      case 43:
        _struct._unique_data_item_43 = value;
        break;
      case 44:
        _struct._unique_data_item_44 = value;
        break;
      case 45:
        _struct._unique_data_item_45 = value;
        break;
      case 46:
        _struct._unique_data_item_46 = value;
        break;
      case 47:
        _struct._unique_data_item_47 = value;
        break;
      case 48:
        _struct._unique_data_item_48 = value;
        break;
      case 49:
        _struct._unique_data_item_49 = value;
        break;
      case 50:
        _struct._unique_data_item_50 = value;
        break;
      case 51:
        _struct._unique_data_item_51 = value;
        break;
      case 52:
        _struct._unique_data_item_52 = value;
        break;
      case 53:
        _struct._unique_data_item_53 = value;
        break;
      case 54:
        _struct._unique_data_item_54 = value;
        break;
      case 55:
        _struct._unique_data_item_55 = value;
        break;
      case 56:
        _struct._unique_data_item_56 = value;
        break;
      case 57:
        _struct._unique_data_item_57 = value;
        break;
      case 58:
        _struct._unique_data_item_58 = value;
        break;
      case 59:
        _struct._unique_data_item_59 = value;
        break;
      case 60:
        _struct._unique_data_item_60 = value;
        break;
      case 61:
        _struct._unique_data_item_61 = value;
        break;
      case 62:
        _struct._unique_data_item_62 = value;
        break;
      case 63:
        _struct._unique_data_item_63 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

const int MAX_SIGNED_MESSAGE_LEN = 92;

const int PACKED_SIGNATURE_LEN = 64;

const int PRIVATE_KEY_LEN = 32;

const int PUBKEY_HASH_LEN = 20;

const int PUBLIC_KEY_LEN = 32;

typedef _c_zks_crypto_init = ffi.Void Function();

typedef _dart_zks_crypto_init = void Function();

typedef _c_zks_crypto_private_key_from_seed = ffi.Uint8 Function(
  ffi.Pointer<ffi.Uint8> seed,
  ffi.Uint8 seed_len,
  ffi.Pointer<ZksPrivateKey> private_key,
);

typedef _dart_zks_crypto_private_key_from_seed = int Function(
  ffi.Pointer<ffi.Uint8> seed,
  int seed_len,
  ffi.Pointer<ZksPrivateKey> private_key,
);

typedef _c_zks_crypto_private_key_to_public_key = ffi.Uint8 Function(
  ffi.Pointer<ZksPrivateKey> private_key,
  ffi.Pointer<ZksPackedPublicKey> public_key,
);

typedef _dart_zks_crypto_private_key_to_public_key = int Function(
  ffi.Pointer<ZksPrivateKey> private_key,
  ffi.Pointer<ZksPackedPublicKey> public_key,
);

typedef _c_zks_crypto_public_key_to_pubkey_hash = ffi.Uint8 Function(
  ffi.Pointer<ZksPackedPublicKey> public_key,
  ffi.Pointer<ZksPubkeyHash> pubkey_hash,
);

typedef _dart_zks_crypto_public_key_to_pubkey_hash = int Function(
  ffi.Pointer<ZksPackedPublicKey> public_key,
  ffi.Pointer<ZksPubkeyHash> pubkey_hash,
);

typedef _c_zks_crypto_sign_musig = ffi.Uint8 Function(
  ffi.Pointer<ZksPrivateKey> private_key,
  ffi.Pointer<ffi.Uint8> msg,
  ffi.Uint8 msg_len,
  ffi.Pointer<ZksSignature> signature_output,
);

typedef _dart_zks_crypto_sign_musig = int Function(
  ffi.Pointer<ZksPrivateKey> private_key,
  ffi.Pointer<ffi.Uint8> msg,
  int msg_len,
  ffi.Pointer<ZksSignature> signature_output,
);
